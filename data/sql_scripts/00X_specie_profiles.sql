/*
INIT ATLAS DB
-------------
Require to be executed on installed GeoNature DB
 */
DO
$$
    BEGIN
        /*
        Table des catégories
          - id category
          - id_parent (self fk)
          - category
          - type (int, varchar, text, bool, etc.)
          - desc

        Table des variables de profiles par espèces:
          - id
          - cd_nom (not null)
          - id_area (nullable) > NULL = default
          - period (PHENOLOGY_PERIOD, nullable) > NULL=default
          - category
          - valeur
          - comment
           */
        CREATE FUNCTION atlas.update_ts_update()
            RETURNS TRIGGER AS
        $update_updated_on_user_task$
        BEGIN
            new.ts_update = now();
            RETURN new;
        END;
        $update_updated_on_user_task$ LANGUAGE 'plpgsql';

        CREATE TABLE atlas.dict_profile_variable_category
        (
            id          INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            id_parent   INTEGER   NULL REFERENCES atlas.dict_profile_variable_category,
            category    VARCHAR,
            description TEXT,
            ts_create   TIMESTAMP NOT NULL DEFAULT now(),
            ts_update   TIMESTAMP NOT NULL DEFAULT now()
        );

        CREATE TRIGGER tri_update_ts_on_dict_profile_variable_category
            BEFORE
                UPDATE
            ON
                atlas.dict_profile_variable_category
            FOR EACH ROW
        EXECUTE PROCEDURE atlas.update_ts_update();

        CREATE TABLE atlas.t_taxa_profiles
        (
            id          INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            cd_nom      INTEGER          NULL REFERENCES atlas.t_taxa(cd_nom),
            id_area     INTEGER          NULL REFERENCES ref_geo.l_areas(id_area),
            period      PHENOLOGY_PERIOD NULL,
            id_category INTEGER          NOT NULL REFERENCES atlas.dict_profile_variable_category(id),
            value       TEXT             NOT NULL,
            description TEXT             NULL,
            ts_create   TIMESTAMP        NOT NULL DEFAULT now(),
            ts_update   TIMESTAMP        NOT NULL DEFAULT now()
        );


        /* Main parent category */
        INSERT INTO atlas.dict_profile_variable_category(category, description)
        VALUES ('breeding_period', 'Parent category for start and end breeding data attribution'),
               ('wintering_period', 'Parent category for start and end breeding data attribution');

        /* Main sub categories */
        INSERT INTO atlas.dict_profile_variable_category(category, id_parent, description)
        SELECT split_part(category, '_', 1) || t.suffix, id, NULL
        FROM atlas.dict_profile_variable_category,
             (SELECT unnest(ARRAY ['_start','_end']) AS suffix) AS t;

        INSERT INTO atlas.t_taxa_profiles(cd_nom, id_area, period, id_category, value)
        SELECT NULL                                                   AS cd_nom,
               id_area,
               split_part(category, '_', 1)::PHENOLOGY_PERIOD         AS period,
               dict_profile_variable_category.id,
               CASE
                   WHEN category LIKE 'breeding_start' THEN '3'
                   WHEN category LIKE 'breeding_end' THEN '13'
                   WHEN category LIKE 'wintering_start' THEN '12-1'
                   WHEN category LIKE 'wintering_end' THEN '1-31' END AS value
        FROM ref_geo.l_areas,
             atlas.dict_profile_variable_category
        WHERE id_type = ref_geo.get_id_area_type('ATLAS_TERRITORY')
          AND area_code LIKE 'FRMET'
          AND id_parent IS NOT NULL;


        DROP MATERIALIZED VIEW atlas.mv_taxa_profiles;
        CREATE MATERIALIZED VIEW atlas.mv_taxa_profiles
        AS
        WITH t0 AS (SELECT cd_nom,
                           id_area,
                           array_agg(value::INT) FILTER (WHERE d1.category LIKE 'breeding_start') AS breeding_start,
                           array_agg(value::INT) FILTER (WHERE d1.category LIKE 'breeding_end')   AS breeding_end,
                           (array_agg(value::VARCHAR)
                            FILTER (WHERE d1.category LIKE 'wintering_start'))[1]                 AS wintering_start,
                           (array_agg(value::VARCHAR)
                            FILTER (WHERE d1.category LIKE 'wintering_end'))[1]                   AS wintering_end
                    FROM atlas.t_taxa_profiles
                             JOIN atlas.dict_profile_variable_category AS d1 ON t_taxa_profiles.id_category = d1.id
                             JOIN atlas.dict_profile_variable_category AS d2 ON d1.id_parent = d2.id
                    GROUP BY cd_nom, id_area),
             t1 AS (SELECT t_taxa.cd_nom,
                           t_taxa.cd_sp,
                           t_taxa.has_subsp,
                           t_taxa.rank,
                           t_taxa.enabled,
                           t_taxa.available,
                           t_taxa.wintering_area_type,
                           t_taxa.all_period_area_type,
                           t_taxa.breeding_area_type,
                           mv_taxa_profiles.cd_nom AS cd_nom_match,
                           mv_taxa_profiles.id_area,
                           mv_taxa_profiles.breeding_start,
                           breeding_end,
                           wintering_start,
                           wintering_end
                    FROM atlas.t_taxa
                             JOIN t0 AS mv_taxa_profiles ON t_taxa.cd_nom = mv_taxa_profiles.cd_nom),
             t2 AS (SELECT t_taxa.cd_nom,
                           t_taxa.cd_sp,
                           t_taxa.has_subsp,
                           t_taxa.rank,
                           t_taxa.enabled,
                           t_taxa.available,
                           t_taxa.wintering_area_type,
                           t_taxa.all_period_area_type,
                           t_taxa.breeding_area_type,
                           mv_taxa_profiles.cd_nom AS cd_nom_match,
                           mv_taxa_profiles.id_area,
                           mv_taxa_profiles.breeding_start,
                           breeding_end,
                           wintering_start,
                           wintering_end
                    FROM atlas.t_taxa
                             CROSS JOIN t0 AS mv_taxa_profiles
                    WHERE t_taxa.cd_nom NOT IN (SELECT t_taxa.cd_nom
                                                FROM atlas.t_taxa
                                                         JOIN t0 AS mv_taxa_profiles ON t_taxa.cd_nom = mv_taxa_profiles.cd_nom)
                      AND mv_taxa_profiles.cd_nom IS NULL),
             t3 AS (SELECT *
                    FROM t1
                    UNION
                    SELECT *
                    FROM t2)
        SELECT *
        FROM t3
        ORDER BY cd_nom, id_area;


        CREATE INDEX ON atlas.mv_taxa_profiles(cd_nom);
        CREATE INDEX ON atlas.mv_taxa_profiles(id_area);

        COMMIT;
    END
$$
;

